# COVID-19 확산 시뮬레이션 프로젝트

이 프로젝트는 COVID-19 확산을 2D 그리드 기반으로 시뮬레이션하는 프로그램입니다. 사람, 건물, 도로를 포함한 가상 환경에서 감염병의 확산을 시각적으로 모델링하고, 다양한 예방 조치(마스크 착용 등)의 효과를 분석할 수 있습니다.

## 주요 기능

### 1. 환경 모델링
- **지도 생성**: 빈 공간, 도로, 집, 건물을 포함한 2D 그리드 생성
- **도로 네트워크**: 수직/수평 도로 랜덤 배치 (최소 간격 보장)
- **건물 배치**: 집과 상업 건물을 도로와 인접하게 배치
- **객체 식별**: 각 지도 요소는 고유 ID로 식별 (빈 공간: 0, 도로: 1, 집: 200-299, 건물: 300-399)

### 2. 개체(사람) 모델링
- **다양한 속성**: 개인별 ID, 위치, 소속 집, 나이 그룹, 마스크 상태, 감염 상태 관리
- **나이 그룹**: 어린이(0), 성인(1), 노인(2)으로 구분하여 다른 감염/회복/사망률 적용
- **마스크 상태**: 미착용(0), 일반 마스크(1), 마스크+페이스쉴드(2)로 구분하여 다양한 감염 확산 영향 모델링
- **감염 상태**: 정상(0), 감염(1), 회복(2), 사망(3) 상태 추적
- **이동 패턴**: 집-건물-집 이동 패턴과 목적지 관리

### 3. 감염병 역학 시뮬레이션
- **접촉 기반 감염**: 거리에 따른 감염 확률 계산 (유클리디안 거리 기반)
- **환경별 확산 모델링**: 실내(집, 건물 내)와 실외(도로) 환경에서의 서로 다른 확산 패턴
- **마스크 효과**: 마스크 착용 여부와 종류에 따른 감염율 차등 적용
- **연령 기반 회복/사망**: 연령대별로 차별화된 회복률과 사망률 적용
- **감염자 자가격리**: 설정한 확률로 감염자가 외출하지 않는 행동 모델링

### 4. 이동 및 경로 탐색
- **BFS 기반 경로 탐색**: 도로 네트워크에서 최단 경로 계산
- **건물 출입 로직**: 건물 출입구 확인 및 내부/외부 이동 관리
- **일간 활동 시뮬레이션**: 집-직장/학교 이동 및 귀가 활동 모델링

### 5. 데이터 저장 및 분석
- **NPY 포맷 저장**: 타임스탬프 기반으로 각 시뮬레이션 단계의 상태 저장
- **통계 추적**: 감염자, 회복자, 사망자 수 일별 추적
- **성능 측정**: 각 시뮬레이션 단계별 실행 시간 측정 및 기록

### 6. 시각화
- **실시간 시각화**: 맵과 사람들의 상태를 시각적으로 표현
- **색상 코딩**: 다양한 객체와 상태를 색상으로 구분 (빈 공간, 도로, 집, 건물, 정상, 감염, 회복, 사망)
- **상세 분석 시각화**: 감염 확산 패턴, 위치별 감염 밀도 등 분석
- **애니메이션**: 시간에 따른 감염 확산 과정 애니메이션 생성
- **한글 폰트 지원**: 운영체제별 적절한 한글 폰트 자동 선택

### 7. 병렬 처리 (MPI)
- **영역 분할**: 맵을 행(row) 기준으로 나누어 각 프로세스가 담당
- **경계 데이터 교환**: 영역을 넘어가는 사람 정보를 프로세스 간 교환
- **병렬 시뮬레이션**: 이동, 감염 확산 등의 연산 병렬화
- **성능 스케일링 분석**: 프로세스 수에 따른 성능 변화 분석

#### 7.1 MPI 병렬 처리 상세 구현

##### 7.1.1 도메인 분할 방식
- **행 기반 분할 (1D Decomposition)**: 전체 맵을 수평 방향으로 분할하여 각 프로세스에 할당
  ```
  프로세스 0: 행 0 ~ (map_size/n_proc - 1)
  프로세스 1: 행 (map_size/n_proc) ~ (2*map_size/n_proc - 1)
  ...
  프로세스 n-1: 행 ((n-1)*map_size/n_proc) ~ (map_size - 1)
  ```
- **균등 분할**: 각 프로세스가 동일한 크기의 영역을 담당 (마지막 프로세스가 예외 가능)
- **분할 함수**: `split_people_by_regions()` 함수에서 맵 크기와 프로세스 수를 기반으로 영역 경계 계산

##### 7.1.2 병렬화된 핵심 알고리즘
- **이동 시뮬레이션 병렬화**:
  - 각 프로세스는 자신의 영역에 위치한 사람들만 처리
  - 사람들이 이동할 때 다음 경우들을 고려:
    1. 프로세스 영역 내에서의 이동 (로컬 처리)
    2. 다른 프로세스 영역으로의 이동 (경계 처리 필요)

- **감염 확산 병렬화**:
  - 로컬 영역 내부 감염: 각 프로세스가 독립적으로 처리
  - 경계 근처 감염: 고스트 셀(ghost cell) 패턴 활용하여 경계 지역 감염 처리
  - 건물/집 내부 감염: 건물/집 위치에 따라 담당 프로세스가 결정되어 처리

- **동기화 지점**:
  - 이동 단계 후: 경계를 넘은 사람들의 정보 교환
  - 일별 통계 계산 시: 전역 감염/회복/사망자 수 집계
  - 데이터 저장 시: 모든 사람 정보를 루트 프로세스로 수집

##### 7.1.3 프로세스 간 통신 패턴
- **점대점 통신 (Point-to-Point)**:
  - `MPI_Send`/`MPI_Recv`: 경계를 넘어가는 사람 객체 정보 교환
  - 각 프로세스는 인접 프로세스와만 통신하여 통신 오버헤드 최소화

- **집합 통신 (Collective)**:
  - `MPI_Gather`: 시뮬레이션 결과 수집 (모든 사람 데이터를 프로세스 0으로 수집)
  - `MPI_Reduce`: 감염/회복/사망자 수 등 통계 데이터 수집
  - `MPI_Barrier`: 모든 프로세스가 특정 단계를 완료했는지 동기화

- **데이터 직렬화 (Serialization)**:
  - Person 객체를 MPI 메시지로 전송하기 위한 직렬화/역직렬화 로직 구현
  - 통신 중 발생 가능한 예외 상황 처리 로직 포함

##### 7.1.4 로드 밸런싱
- **정적 로드 밸런싱**: 시뮬레이션 시작 시 맵 크기에 따른 균등 분할
- **인구 밀도 고려**: 실제 사람 객체 수는 영역마다 다를 수 있어 부하 불균형 가능성 존재
- **최적화 가능성**: 인구 밀도에 따른 동적 로드 밸런싱 구현 가능성 제시

##### 7.1.5 병렬화 한계 및 개선점
- **통신 오버헤드**: 영역 경계를 넘나드는 사람이 많을수록 통신량 증가
- **동기화 병목**: 모든 프로세스가 동기화해야 하는 지점이 많을수록 성능 저하
- **메모리 사용**: 각 프로세스가 전체 맵 정보를 복사하여 사용하는 메모리 중복
- **I/O 병목**: 데이터 저장 시 프로세스 0에 모든 정보가 집중되는 현상

##### 7.1.6 구현된 병렬 함수
- `split_people_by_regions()`: 초기 사람 분배
- `exchange_boundary_data()`: 경계를 넘어간 사람 교환
- `gather_all_people()`: 모든 사람 정보 수집
- `run_simulation_parallel()`: 병렬 시뮬레이션 실행 메인 함수

### 8. 성능 분석 도구
- **실행 시간 측정**: 전체 시뮬레이션 및 각 단계별 실행 시간 기록
- **타이밍 리포트**: JSON 형식으로 성능 데이터 저장
- **비교 분석**: 순차 실행과 병렬 실행 성능 비교
- **스케일링 효율성**: 프로세스 수 증가에 따른 성능 향상 분석

## 실행 방법

### 순차 실행 (단일 프로세스)
```bash
python main.py
```

### 병렬 실행 (MPI)
```bash
# 4개 프로세스로 실행
./run_parallel_simulation.sh 4

# 또는 직접 mpiexec 사용
mpiexec -n 4 python main.py
```

### 성능 측정 및 분석
```bash
# 스케일링 실험 실행 (1, 2, 4, 8, 16 프로세스)
./run_scaling_experiments.sh

# 결과 분석
python analyze_scaling.py
```

### 시각화 및 비디오 생성
```bash
# 시뮬레이션 결과 시각화
python visualization.py [시뮬레이션_데이터_폴더]

# 비디오 생성
python create_video.py [시뮬레이션_데이터_폴더]
```

## 프로젝트 구조

- **main.py**: 주요 시뮬레이션 코드 및 핵심 로직
- **timing_results.py**: 실행 시간 측정 및 기록 도구
- **visualization.py**: 시뮬레이션 결과 시각화 도구
- **create_video.py**: 시뮬레이션 결과로 영상 생성
- **analyze_scaling.py**: 병렬 성능 스케일링 분석
- **compare_timings.py**: 다양한 조건에서의 성능 비교
- **detailed_analysis.py**: 감염 패턴 상세 분석
- **run_parallel_simulation.sh**: MPI 기반 병렬 실행 스크립트
- **run_scaling_batch.sh**: 다양한 프로세스 수로 배치 실행
- **run_scaling_experiments.sh**: 스케일링 실험 실행 스크립트
- **debug_parallel_simulation.sh**: 병렬 실행 디버깅 도구

## 데이터 형식

### 시뮬레이션 데이터 저장 형식
- **{timestamp}_map_array.npy**: 맵 배열 데이터
- **{timestamp}_people.npy**: 사람 정보 (ID, 위치, 속성 등)
- **{timestamp}_houses.npy**: 집 정보 (ID, 위치, 크기 등)
- **{timestamp}_buildings.npy**: 건물 정보 (ID, 위치, 크기 등)

## 시뮬레이션 매개변수

주요 매개변수를 조정하여 다양한 시나리오 시뮬레이션이 가능합니다:

### 맵 생성
- 맵 크기, 집/건물 수 및 크기, 도로 폭 및 개수

### 인구 특성
- 집별 인구 수, 연령대 분포, 마스크 착용률

### 감염병 특성
- 초기 감염률, 마스크별 감염률, 연령별 회복률/사망률
- 감염자의 자가격리 확률

### 시뮬레이션 실행
- 시뮬레이션 기간(일수), 건물 내 감염 시뮬레이션 반복 횟수

## 활용 예시

이 시뮬레이션을 통해 다음과 같은 분석이 가능합니다:

1. 마스크 착용률에 따른 감염 확산 속도 비교
2. 감염자 자가격리 효과 분석
3. 인구 밀도와 감염 확산의 상관관계 연구
4. 도시 구조(도로 배치 등)가 감염병 확산에 미치는 영향
5. 연령별 취약 인구 분포와 사망률 관계 분석
6. 다양한 방역 정책의 효과 시뮬레이션

## 성능 최적화 팁

1. **프로세스 수 조정**: 컴퓨터 코어 수와 맵 크기에 맞게 프로세스 수 조정
2. **메모리 관리**: 대규모 시뮬레이션의 경우 메모리 사용량 주의
3. **통신 최적화**: MPI 병렬 실행 시 데이터 교환량 최소화
4. **저장 주기 조정**: 저장 빈도를 낮추어 I/O 병목 현상 감소

## MPI 병렬 처리 심화 내용

### 1. MPI 통신 최적화 기법

#### 1.1 통신 최소화 전략
- **로컬 계산 우선**: 각 프로세스가 최대한 로컬 연산에 집중하도록 알고리즘 설계
- **통신 빈도 감소**: 여러 번의 작은 통신 대신 적은 횟수의 큰 통신으로 병합
- **비동기 통신 활용**: 중요하지 않은 통신에 `MPI_Isend`/`MPI_Irecv` 활용 가능성

#### 1.2 데이터 교환 최적화
- **경계 영역 교환 방식**:
  ```python
  # 각 프로세스별로 필요한 사람들을 직접 교환
  for target_rank in range(size):
      # 현재 프로세스에서 target_rank로 보낼 사람들 필터링
      region_start = target_rank * (map_size // size)
      region_end = (target_rank + 1) * (map_size // size) if target_rank < size - 1 else map_size
      send_people = [p for p in outgoing_people if region_start <= p.x < region_end]
      
      # 통신 객체 생성 및 전송
      send_obj = send_people
      recv_obj = comm.sendrecv(send_obj, dest=target_rank, source=target_rank)
      
      # 받은 사람들을 로컬 리스트에 추가
      updated_local_people.extend(recv_obj)
  ```

- **버퍼링 전략**: 작은 데이터를 모아서 한 번에 전송하여 통신 오버헤드 감소
- **맵 경계 특별 처리**: 맵 경계에 있는 프로세스는 한쪽 방향으로만 통신

### 2. 병렬화된 주요 알고리즘 구현 세부사항

#### 2.1 도메인 분할 세부 구현
```python
def split_people_by_regions(people_list, map_size, num_processes):
    """사람들을 프로세스별 영역으로 분할"""
    comm = MPI.COMM_WORLD 
    rank = comm.Get_rank()
    
    # 영역 계산
    region_height = map_size // num_processes
    start_row = rank * region_height
    end_row = (rank + 1) * region_height if rank < num_processes - 1 else map_size
    
    # 담당 영역 내의 사람들만 필터링
    local_people = [person for person in people_list if start_row <= person.x < end_row]
    
    return local_people, start_row, end_row
```

#### 2.2 감염 시뮬레이션 병렬화
- **로컬 감염 처리**: 각 프로세스가 자신의 영역 내 감염자와 정상인 간의 접촉 시뮬레이션
- **고스트 영역 처리**: 영역 경계에서의 감염 전파 처리를 위한 추가 로직
- **통계 데이터 수집**: 각 프로세스의 감염/회복/사망 데이터를 병합하여 전체 통계 계산

#### 2.3 이동 시뮬레이션 병렬화
- **로컬 경로 탐색**: 각 프로세스가 자신의 영역 내에서 BFS 기반 경로 탐색 수행
- **영역 경계 처리**: 경로가 다른 프로세스의 영역으로 넘어갈 때 데이터 교환 처리
- **건물 출입 병렬 처리**: 건물 위치에 따라 담당 프로세스가 출입 로직 처리

### 3. 병렬 성능 분석 및 병목 지점

#### 3.1 스케일링 분석 상세 정보
- **강한 스케일링(Strong Scaling)**: 동일한 문제 크기에서 프로세스 수 증가에 따른 성능 향상
- **약한 스케일링(Weak Scaling)**: 프로세스 수에 비례하여 문제 크기가 증가할 때의 성능
- **효율성 계산**: `E(p) = T(1) / (p * T(p))` (이상적으로는 1에 가까울수록 좋음)
- **암달의 법칙**: 병렬화 불가능한 부분이 전체 성능 향상의 한계를 결정

#### 3.2 병렬 실행의 주요 병목 지점
- **데이터 직렬화/역직렬화**: 객체 데이터를 전송 가능한 형태로 변환하는 과정의 오버헤드
- **동기화 지연**: 프로세스 간 처리 속도 차이로 인한 대기 시간
- **통신 오버헤드**: 메시지 전송 시간 및 네트워크 지연
- **로드 불균형**: 영역별 작업량 차이로 인한 일부 프로세스의 유휴 상태

#### 3.3 성능 최적화를 위한 실험적 분석
- **통신/계산 비율**: 다양한 맵 크기와 인구 밀도에서의 통신과 계산 시간 비교
- **메모리 사용량**: 프로세스 수 증가에 따른 메모리 사용량 변화 분석
- **I/O 병목**: 데이터 저장 및 불러오기 단계에서의 병목 현상 분석
- **최적 프로세스 수**: 특정 문제 크기에 대한 최적의 프로세스 수 도출

### 4. MPI 구현의 기술적 세부사항

#### 4.1 예외 처리 및 오류 복구
- **통신 실패 대응**: 통신 중 발생할 수 있는 예외 상황에 대한 처리 로직
- **동기화 실패 복구**: 일부 프로세스 지연 시 대응 방안
- **디버깅 로직**: MPI 통신 오류 추적을 위한 로깅 기능

#### 4.2 고급 MPI 기능 활용
- **커스텀 데이터타입**: 복잡한 객체 전송을 위한 MPI 데이터타입 정의
- **불균형 부하 대응**: 동적 로드 밸런싱을 위한 전략
- **하이브리드 병렬화**: MPI와 OpenMP 결합 가능성
